/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
    for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to, key) && key !== except)
                __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/canvasMindMap.ts
var canvasMindMap_exports = {};
__export(canvasMindMap_exports, {
    default: () => CanvasMindMap
});
module.exports = __toCommonJS(canvasMindMap_exports);


// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
    const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
    return removers.length === 1 ? removers[0] : function () {
        removers.forEach((r) => r());
    };
}
function around1(obj, method, createWrapper) {
    const original = obj[method], hadOwn = obj.hasOwnProperty(method);
    let current = createWrapper(original);
    if (original)
        Object.setPrototypeOf(current, original);
    Object.setPrototypeOf(wrapper, current);
    obj[method] = wrapper;
    return remove;
    function wrapper(...args) {
        if (current === original && obj[method] === wrapper)
            remove();
        return current.apply(this, args);
    }
    function remove() {
        if (obj[method] === wrapper) {
            if (hadOwn)
                obj[method] = original;
            else
                delete obj[method];
        }
        if (current === original)
            return;
        current = original;
        Object.setPrototypeOf(wrapper, original || Function);
    }
}

// src/utils.ts
var random = (e) => {
    let t = [];
    for (let n = 0; n < e; n++) {
        t.push((16 * Math.random() | 0).toString(16));
    }
    return t.join("");
},
    addEdge = (canvas, edgeID, fromEdge, toEdge) => {
        if (!canvas) return;
        const data = canvas.getData();
        if (!data) return;
        canvas.importData({
            'edges': [...data.edges, {
                'id': edgeID,
                'fromNode': fromEdge.node.id,
                'fromSide': fromEdge.side,
                'toNode': toEdge.node.id,
                'toSide': toEdge.side
            }],
            'nodes': data.nodes
        });

        canvas.requestFrame();
    },
    adjustTreeY = (rootNode, canvas) => {
        const rootNodeHeight = getNodeHeight(rootNode, canvas),
            location_y = rootNode.y + rootNode.height / 2 - rootNodeHeight / 2,
            groups = getGroups(canvas);

        adjustNodeY(rootNodeHeight, canvas, location_y);
        adjustGroups(groups);
    },
    getNodeHeight = (node, canvas) => {
        const childNodes = getChildNodes(node, canvas);

        if (childNodes.length === 0)return node.height;

        const nodeHeights = childNodes.map(node => {
            return getNodeHeight(node, canvas);
        }),
            childNodeCnt = nodeHeights.length,
            totalHeight = nodeHeights.reduce((total, height) => total + height, 0),
            gapCnt = childNodeCnt > 1 ? childNodeCnt - 1 : 0;

        return Math.max(totalHeight + gapCnt * 20, node.height);
    },
    adjustNodeY = async (node, canvas, location_y) => {
        const childNodes = getChildNodes(node, canvas);
        if (childNodes.length === 0) return;

        let currentY = location_y;

        for (let i = 0; i < childNodes.length; i++) {
            const node = childNodes[i],
                height = getNodeHeight(node, canvas),
                y = currentY + height / 2;

            node.x += node.width + 200;
            node.y = y - node.height / 2;

            node.moveTo({
                'x': node.x,
                'y': node.y
            });

            const new_y = y - getSubNodeHeight(node, canvas) / 2;

            adjustNodeY(node, canvas, new_y);
            currentY += height + 20;
        }
    },
    getSubNodeHeight = (node, canvas) => {
        const childNodes = getChildNodes(node, canvas);
        if (childNodes.length === 0) return node.height;

        const subNodeHeights = childNodes.map(subNode => {
            return getNodeHeight(subNode, canvas);
        });
        const subNodeCount = subNodeHeights.length;
        const totalHeight = subNodeHeights.reduce((total, height) => total + height, 0);
        const gapCount = subNodeCount > 1 ? subNodeCount - 1 : 0;

        return totalHeight + gapCount * 20;
    },
    getChildNodes = (node, canvas) => {
        let edges = canvas.getEdgesForNode(node).filter(edge => {
            return edge.from.node.id === node.id && edge.to.side === "left";
        });

        let childNodes = [];

        for (let i = 0; i < edges.length; i++) {
            let childNode = edges[i].to.node;
            childNodes.push(childNode);
        }

        if (childNodes.length > 1) {
            childNodes.sort((a, b) => {
                return a.y - b.y;
            });
        }

        return childNodes;
    },
    adjustGroups = (groupData) => {
        const canvasView = app.workspace.getLeavesOfType('canvas').first()?.view;
        const canvas = canvasView?.canvas;
        if (!canvas) return false;
        groupData.forEach((group) => {
            canvas.nodes.forEach((node) => {
                if (node.id === group.groupNode.id) {
                    group.groupNode = node;
                    console.log("get group node", node);
                }
                if (node.id === group.topChild.id) {
                    console.log("get top node", node);
                    group.topChild = node;
                }
                if (node.id === group.bottomChild) {
                    console.log("get bottom node", node);
                    group.bottomChild = node;
                }
                if (node.id === group.leftChild) {
                    console.log("get left node", node);
                    group.leftChild = node;
                }
                if (node.id === group.rightChild) {
                    console.log("get right node", node);
                    group.rightChild = node;
                }
            });
            group.groupNode.y = group.topChild.y - 20;
            group.groupNode.height = group.bottomChild.y + group.bottomChild.height - group.groupNode.y + 20;
            group.groupNode.x = group.leftChild.x - 20;
            group.groupNode.width = group.rightChild.x + group.rightChild.width - group.groupNode.x + 20; 
            group.groupNode.moveTo({
                'x': group.groupNode.x,
                'y': group.groupNode.y,
                'width': group.groupNode.width,
                'height': group.groupNode.height
            });
        });
    },
    getGroups = (canvas) => {
        const groups = [];
        canvas.nodes.forEach((node) => {
            if (node.getData().type === "group") {
                const containingNodes = canvas.getContainingNodes(node.getBBox()).filter((n) => {
                    return n.id !== node.id;
                });
                console.log("containingNodes", containingNodes);

                const topChild = containingNodes.reduce((prev, curr) => {
                    return prev.y < curr.y ? prev : curr;
                });
                const bottomChild = containingNodes.reduce((prev, curr) => {
                    return prev.y + prev.height > curr.y + curr.height ? prev : curr;
                });
                const leftChild = containingNodes.reduce((prev, curr) => {
                    return prev.x < curr.x ? prev : curr;
                });
                const rightChild = containingNodes.reduce((prev, curr) => {
                    return prev.x + prev.width > curr.x + curr.width ? prev : curr;
                });
                const group = {
                    groupNode: node,
                    topChild: topChild,
                    bottomChild: bottomChild,
                    leftChild: leftChild,
                    rightChild: rightChild
                };
                groups.push(group);
            }
        });
        return groups;
    },
    import_obsidian2 = require('obsidian'),
    en_default = {
        'createChildNode': "Create child node",
        'createSiblingNode': "Create sibling node"
    },
    zh_cn_default = {
        'createChildNode': '添加子节点',
        'createSiblingNode': "添加兄弟节点"
    },
    localeMap = {
        'en': en_default,
        'zh-cn': zh_cn_default
    },
    locale = localeMap[import_obsidian2.moment.locale()];

function t(_0x559b31) {
    return locale && locale[_0x559b31] || en_default[_0x559b31];
}

var CanvasMindMap = class extends require("obsidian").Plugin {
    async .onload() {
        this.patchCanvas();
        this.patchMarkdownFileInfo();
        this.patchCanvasNode();
    }

    patchCanvas() {
        const createEdge = async (node1, node2, canvas) => {

        },
            navigate = (canvas, direction) => {
                return _0x138488;
            },
            childNode = async (_0x386b6d, _0x3fe4d7, _0xb08079) => {
                let _0x34b1c4;

                return _0x34b1c4;
            },
            createChildNode = async (canvas, condition) => {
                var _0x467c55, _0x159ed7;
                if (canvas.selection.size !== 1) return;
                const selectedNode = canvas.selection.entries().next().value[1];
                if (selectedNode.isEditing && condition) return;

                let prevParentEdges = canvas.getEdgesForNode(selectedNode).filter(_0xb580b1 => {
                    return _0xb580b1.from.node.id === selectedNode.id && _0xb580b1.to.side === 'left';
                }),
                    tempChildNode;

                if (prevParentEdges.length === 0) {
                    tempChildNode = await childNode(canvas, selectedNode, selectedNode.y);
                } else {
                    let prevAllNodes = [];

                    for (let _0x340c68 = 0; _0x340c68 < (prevParentEdges == null ? void 0 : prevParentEdges.length); _0x340c68++) {
                        let _0x9157bf = prevParentEdges[_0x340c68].to.node;

                        prevAllNodes.push(_0x9157bf);
                    }

                    prevAllNodes.length > 1 && prevAllNodes.sort((_0x598051, _0x2f81a8) => {
                        return _0x598051.y - _0x2f81a8.y;
                    });

                    const _0x5d9f9a = ((_0x467c55 = prevAllNodes[prevAllNodes.length - 1]) == null ? void 0 : _0x467c55.y) + ((_0x159ed7 = prevAllNodes[prevAllNodes.length - 1]) == null ? void 0 : _0x159ed7.height) + 20;

                    tempChildNode = await childNode(canvas, selectedNode, _0x5d9f9a);

                    prevAllNodes.push(tempChildNode);

                    prevAllNodes.sort((_0x59572f, _0x2be96f) => {
                        return _0x59572f.y - _0x2be96f.y;
                    });

                    if (prevAllNodes.length === 1) {
                        return;
                    }
                    // TODO
                    adjustTreeY(getRootNode(selectedNode, canvas), canvas);
                }

                return tempChildNode;
            },
            getRootNode = (node, canvas) => {
                let edges = canvas.getEdgesForNode(node).filter(_0x18c346 => {
                    return _0x18c346.to.node.id === node.id && _0x18c346.from.side === "right";
                });
                if (edges.length == 0)return node;
                let parentNode = edges[0].from.node;
                return getRootNode(parentNode, canvas);
            },
            createSiblingNode = async (canvas, condition) => {
                if (canvas.selection.size !== 1) return;
                const selectedNode = canvas.selection.entries().next().value[1];
                if (selectedNode.isEditing && condition) return;
                const edges = canvas.getEdgesForNode(selectedNode).filter(edge => {
                    return edge.to.node.id === selectedNode.id;
                });
                if (edges.length === 0)return;
                const parentNode = edges[0].from.node,
                    distanceY = selectedNode.y + selectedNode.height / 2 + 110,
                    tempChildNode = await childNode(canvas, parentNode, distanceY);

                adjustTreeY(getRootNode(parentNode, canvas), canvas);
                return tempChildNode;
            },
            patchCanvas = () => {
                var _0x221660;

                console.log("patchCanvas");

                const canvasView = (_0x221660 = app.workspace.getLeavesOfType("canvas").first()) == null ? void 0 : _0x221660.view,
                    canvas = canvasView == null ? void 0 : canvasView.canvas;

                if (!canvasView) {
                    return false;
                }

                const _0x21ecd0 = canvas.constructor,
                    onOpen = around(canvasView.constructor.prototype, {
                        'onOpen': _0x180e63 => async function () {
                            console.log("onOpen");
                            return _0x180e63.call(this);
                        },
                        'onClose': _0x1933d9 => async function () {
                            console.log("onclose");
                            return _0x1933d9.call(this);
                        },
                        'onPaneMenu': _0x3e7644 => async function () {
                            console.log("onPaneMenu");
                            return _0x3e7644.call(this);
                        },
                        'OnResize': _0x549100 => async function () {
                            console.log("OnResize");
                            return _0x549100.call(this);
                        }
                    }),
                    uninstaller = around(_0x21ecd0.prototype, {
                        'onContextMenu': _0x5f1ce4 => async function (_0xc49bd5) {
                            console.log("onContextMenu");
                            return _0x5f1ce4.call(this, _0xc49bd5);
                        },
                        'onDoubleClick': _0x8ad22a => async function (_0x14ad63) {
                            console.log("onDoubleClick");
                            return _0x8ad22a.call(this, _0x14ad63);
                        },
                        'onKeydown': onKeydown => async function (next) {
                            console.log('onKeydown');

                            if (next.key === "Backspace" || next.key === 'Delete') {
                                console.log('Delete');

                                if (this.selection.size !== 1) {
                                    console.log("selection size is not one");
                                    return onKeydown.call(this, next);
                                }

                                const childNode = this.selection.entries().next().value[1];

                                if (childNode.isEditing) {
                                    console.log("node is editing");
                                    return;
                                }

                                console.log("adjust");
                                adjustTreeY(getRootNode(childNode, canvas), canvas);

                                onKeydown.call(this, next);

                                return;
                            }

                            onKeydown.call(this, next);
                        },
                        'onSelectionContextMenu': _0x1083db => async function (_0x17819b) {
                            console.log('onSelectionContextMenu');
                            return _0x1083db.call(this, _0x17819b);
                        },
                        'onResize': _0x2883b6 => async function (_0xdc94b7) {
                            console.log("onResize");
                            return _0x2883b6.call(this, _0xdc94b7);
                        },
                        'onTouchdown': _0x544bfd => async function (_0x12713a) {
                            console.log("onTouchdown");
                            return _0x544bfd.call(this, _0x12713a);
                        },
                        'onWheel': _0x5a8787 => async function (_0x2137d8) {
                            console.log("onWheel");
                            return _0x5a8787.call(this, _0x2137d8);
                        },
                        'onPointerdown': onPointerdown => async function (_0x202e50) {
                            console.log('onPointerdown');
                            setTimeout(() => {
                                const _0x3bacdb = document.querySelector(".canvas-menu");

                                if (_0x3bacdb !== null) {
                                    console.log("canvasMenun", _0x3bacdb);

                                    if (!_0x3bacdb.querySelector("button[aria-label=\"" + t('createChildNode') + "\"]")) {
                                        const _0x4fb1eb = document.createElement('button');

                                        _0x4fb1eb.className = "clickable-icon";

                                        _0x4fb1eb.setAttribute("aria-label", t("createChildNode"));

                                        _0x4fb1eb.setAttribute("data-tooltip-position", "top");

                                        this.app.getTheme() === "moonstone" ? _0x4fb1eb.innerHTML = "<svg t=\"1686470194456\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1122\" width=\"16\" height=\"16\"><path d=\"M928 640h-256c-17.066667 0-32 14.933333-32 32V768H288V416h128c17.066667 0 32-14.933333 32-32V128c0-17.066667-14.933333-32-32-32h-320C78.933333 96 64 110.933333 64 128v256c0 17.066667 14.933333 32 32 32h128v384c0 17.066667 14.933333 32 32 32h384v96c0 17.066667 14.933333 32 32 32h256c17.066667 0 32-14.933333 32-32v-256c0-17.066667-14.933333-32-32-32zM128 160h256v192H128v-192z\" fill=\"#212121\" p-id=\"1123\"></path><path d=\"M608 320h128v128c0 17.066667 14.933333 32 32 32s32-14.933333 32-32v-128h128c17.066667 0 32-14.933333 32-32s-14.933333-32-32-32h-128V128c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v128h-128c-17.066667 0-32 14.933333-32 32s14.933333 32 32 32z\" fill=\"#212121\" p-id=\"1124\"></path></svg>" : _0x4fb1eb.innerHTML = "<svg t=\"1686479002541\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"2832\" width=\"16\" height=\"16\"><path d=\"M928 640h-256c-17.066667 0-32 14.933333-32 32V768H288V416h128c17.066667 0 32-14.933333 32-32V128c0-17.066667-14.933333-32-32-32h-320C78.933333 96 64 110.933333 64 128v256c0 17.066667 14.933333 32 32 32h128v384c0 17.066667 14.933333 32 32 32h384v96c0 17.066667 14.933333 32 32 32h256c17.066667 0 32-14.933333 32-32v-256c0-17.066667-14.933333-32-32-32zM128 160h256v192H128v-192z\" fill=\"#bfbfbf\" p-id=\"2833\"></path><path d=\"M608 320h128v128c0 17.066667 14.933333 32 32 32s32-14.933333 32-32v-128h128c17.066667 0 32-14.933333 32-32s-14.933333-32-32-32h-128V128c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v128h-128c-17.066667 0-32 14.933333-32 32s14.933333 32 32 32z\" fill=\"#bfbfbf\" p-id=\"2834\"></path></svg>";

                                        _0x4fb1eb.addEventListener('click', async () => {
                                            const _0x307075 = await createChildNode(this, false);

                                            if (!_0x307075) {
                                                return;
                                            }

                                            setTimeout(() => {
                                                _0x307075.startEditing();

                                                this.zoomToSelection();
                                            }, 0);
                                        });

                                        _0x3bacdb.appendChild(_0x4fb1eb);
                                    }

                                    if (!_0x3bacdb.querySelector("button[aria-label=\"" + t("createSiblingNode") + "\"]")) {
                                        const _0x2508d9 = document.createElement("button");

                                        _0x2508d9.className = "clickable-icon";

                                        _0x2508d9.setAttribute('aria-label', t('createSiblingNode'));

                                        _0x2508d9.setAttribute('data-tooltip-position', "top");

                                        this.app.getTheme() === 'moonstone' ? _0x2508d9.innerHTML = "<svg t=\"1686470696759\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1547\" width=\"16\" height=\"16\"><path d=\"M384 704c17.066667 0 32-14.933333 32-32v-128h128c17.066667 0 32-14.933333 32-32s-14.933333-32-32-32h-128v-128c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v128h-128c-17.066667 0-32 14.933333-32 32s14.933333 32 32 32h128v128c0 17.066667 14.933333 32 32 32z\" fill=\"#212121\" p-id=\"1548\"></path><path d=\"M938.666667 53.333333H682.666667c-17.066667 0-32 14.933333-32 32v106.666667h-554.666667C78.933333 192 64 206.933333 64 224v576c0 17.066667 14.933333 32 32 32H640v96c0 17.066667 14.933333 32 32 32h256c17.066667 0 32-14.933333 32-32v-256c0-17.066667-14.933333-32-32-32h-256c-17.066667 0-32 14.933333-32 32V768H128V256h522.666667v85.333333c0 17.066667 14.933333 32 32 32h256c17.066667 0 32-14.933333 32-32V85.333333c0-17.066667-14.933333-32-32-32z m-32 256h-192v-192h192v192z\" fill=\"#212121\" p-id=\"1549\"></path></svg>" : _0x2508d9.innerHTML = "<svg t=\"1686479130635\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3206\" width=\"16\" height=\"16\"><path d=\"M384 704c17.066667 0 32-14.933333 32-32v-128h128c17.066667 0 32-14.933333 32-32s-14.933333-32-32-32h-128v-128c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v128h-128c-17.066667 0-32 14.933333-32 32s14.933333 32 32 32h128v128c0 17.066667 14.933333 32 32 32z\" fill=\"#bfbfbf\" p-id=\"3207\"></path><path d=\"M938.666667 53.333333H682.666667c-17.066667 0-32 14.933333-32 32v106.666667h-554.666667C78.933333 192 64 206.933333 64 224v576c0 17.066667 14.933333 32 32 32H640v96c0 17.066667 14.933333 32 32 32h256c17.066667 0 32-14.933333 32-32v-256c0-17.066667-14.933333-32-32-32h-256c-17.066667 0-32 14.933333-32 32V768H128V256h522.666667v85.333333c0 17.066667 14.933333 32 32 32h256c17.066667 0 32-14.933333 32-32V85.333333c0-17.066667-14.933333-32-32-32z m-32 256h-192v-192h192v192z\" fill=\"#bfbfbf\" p-id=\"3208\"></path></svg>";
                                        console.log(require("obsidian").moment.locale());

                                        _0x2508d9.addEventListener("click", async () => {
                                            const _0x39e7e9 = await createSiblingNode(this, false);

                                            if (!_0x39e7e9) {
                                                console.log("创建兄弟节点失败");
                                                return;
                                            }

                                            setTimeout(() => {
                                                _0x39e7e9.startEditing();

                                                this.zoomToSelection();
                                            }, 0);
                                        });

                                        _0x3bacdb.appendChild(_0x2508d9);
                                    }
                                }
                            }, 150);
                            return onPointerdown.call(this, _0x202e50);
                        }
                    });

                this.register(uninstaller);
                this.register(onOpen);
                canvas == null ? void 0 : canvas.view.leaf.rebuildView();
                console.log("Obsidian-Canvas-MindMap: canvas view patched");
                return true;
            };

        this.app.workspace.onLayoutReady(() => {
            if (!patchCanvas()) {
                const _0x45f080 = app.workspace.on("layout-change", () => {
                    patchCanvas() && app.workspace.offref(_0x45f080);
                });

                this.registerEvent(_0x45f080);
            }
        });
    }


	patchCanvasNode() {
		const patchNode = () => {
			const canvasView = app.workspace.getLeavesOfType("canvas").first()?.view;
			// @ts-ignore
			const canvas = canvasView?.canvas;
			if(!canvas) return false;

			const node = Array.from(canvas.nodes).first();
			if (!node) return false;

			// @ts-ignore
			const nodeInstance = node[1];

			const uninstaller = around(nodeInstance.constructor.prototype, {
				setColor: (next: any) =>
					function (e: any, t: any) {
						next.call(this, e, t);
						this.canvas.getEdgesForNode(this).forEach((edge: any) => {
							if(edge.from.node === this) {
								edge.setColor(e, true);
								edge.render();
								// edge.to.node.setColor(e, true);
							}
						})
						canvas.requestSave();
					},
			});
			this.register(uninstaller);

			console.log("Obsidian-Canvas-MindMap: canvas node patched");
			return true;
		}

		this.app.workspace.onLayoutReady(() => {
			if (!patchNode()) {
				const evt = app.workspace.on("layout-change", () => {
					patchNode() && app.workspace.offref(evt);
				});
				this.registerEvent(evt);
			}
		});
	}

	patchMarkdownFileInfo() {
		const patchEditor = () => {
			const editorInfo = app.workspace.activeEditor;
			if(!editorInfo) return false;

			const patchEditorInfo = editorInfo.constructor;

			const uninstaller = around(patchEditorInfo.prototype, {
				showPreview: (next) =>
					function (e: any) {
						next.call(this, e);
						if(e) {
							this.node.canvas.wrapperEl.focus();
							this.node?.setIsEditing(false);
						}
					},
			});
			this.register(uninstaller);

			console.log("Obsidian-Canvas-MindMap: markdown file info patched");
			return true;
		}

		this.app.workspace.onLayoutReady(() => {
			if (!patchEditor()) {
				const evt = app.workspace.on("file-open", () => {
					setTimeout(()=>{
						patchEditor() && app.workspace.offref(evt);
					}, 100);
				});
				this.registerEvent(evt);
			}
		});
	}

};